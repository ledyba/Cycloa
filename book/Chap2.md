# 0x02 設計は計画的に。

今までは文章だけでしたが、このセクションからは、ファミコンにターゲットを絞って、プログラムを本格的に組み上げていきます。…が、コードを書くのはもう少し先です…。

ソフトウェアの組み方には概ね、具体的なパーツから作って最後にくっ付ける「ボトムアップ」タイプと、全体の構造を決めて、それには何が必要で…とパーツの立ち位置を決めてからつくっていく「トップダウン」タイプの２つのタイプがありますが、対象についてあまり詳しくない場合は、トップダウンの方が時間はかかるけど、うまくいくことが多いように感じています。

私たちは、まだあまりファミコンの事を知りませんから、今回はトップダウン式で考えていきましょう。

## 0x0201 司令塔のCPUの立場から、全体の設計を考えよう

0x01で、どんなパーツがあるのかについては既に検討しました。この６つ（CPU、メモリ、カセット、ビデオ、サウンド、コントローラ）を、どのようにまとめ上げていくかを考えていきましょう。

コンピュータの中心部は、やはり司令塔たるCPUでしょう。このCPUから”ファミコンの他のパーツはどのように見えるのか”という視点から、考えてみましょう。

### バスとメモリーマップドIO

ファミコンのCPUは「MOS 6502」という、Apple2にも使われた超有名な伝説のCPUです。詳しくは実装する時に解説するとして1、このCPUは基本的に8ビットのCPUです。つまり、6502は基本的に8ビットの0〜255までの数値を一度に扱えます。…いや、「しか扱えない」と言ったほうが、64 bit CPUが普及した昨今はいいのかもしれませんね。ちなみに掛け算も割り算もできないので、足し算と引き算だけでそれらを自分で計算する必要があります。

そして、計算するときに使う値の場所を指定するためにアドレスが必要ですが、6502では16ビットです。つまり、ポインタ2の大きさが16bitということです。こちらも最近のCPUだと64bitですが、ファミコンはその1/4の大きさしかありません。最近のCPUは演算できるビット数とポインタのビット数がだいたい同じですが、この時代のCPUは演算するビット数とポインタのビット数が異なることはよくあったようです。

これらをすこしハードの視点に翻訳しましょう。この6502 CPUには、データを入力・出力するための8ビットのデータの通り道と、その場所（アドレス）を指し示すための16ビットのデータの通り道がつながっています。これらをそれぞれ「データバス」、「アドレスバス」と呼び、これらはだいたいセットで単に「バス」と呼びます。基本的に、6502はこのバスを通じて外部とつながります。

でも、まってください。CPUにはいろいろな部品がぶら下がっているはずです。メモリーとか、グラフィックを制御するPPUとか、サウンドを生成するAPUとか、コントローラとか、カセットとか。でもバスしか通り道が（これから紹介する割り込みを除いて）ないのに、どうやって？

その解決策が「メモリマップドIO」です。

アドレスは数値です。さっき言ったとおり16ビットなので、65536種類の場所を指定できます。

が、しかし、いわゆる「普通の変数」が格納されているRAMは2048バイトしかないので、全アドレス65536個のうち2048個だけあればRAMのどこに読み書きするのかの指定ができます。つまり、殆どあまってます。

ファミコン（に限らずメモリマップドIOのマシン）では、この空きを有効活用します。1にあるとおり、RAMのアドレスは最初の方だけで、残りはPPUやAPUのような他のパーツに割り当てています。これはCPUからの視点で見ると、まるで「普通の変数」に読み書きしているように上記の他のパーツに割り当てているアドレスに読み書きすると、PPUなどの他の部品に司令を飛ばしたり、その結果を受け取ったりすることができるということです。

これを実現するために、ファミコンのハードウェアでは、それぞれのパーツに繋ぐためにCPUから出たバスはいろいろ分岐したりしています。わたしたちも、ソフトウェア的にそれを再現する必要があります。

具体的な設計としては、全体をまとめ上げるような存在のクラスを作って、そのクラスにバスの役割を担ってもらい、CPUが読み書きするデータの仲介を行ってもらいましょう。

### 割り込み

このメモリーマップドIOという方式では、情報をやりとりする主導権は、CPUにあります。つまり、CPUが思った時にCPUが各パーツに（特定のアドレスに書き込むことで）司令を与え、CPUが欲しいなと思ったときに各パーツから（特定のアドレスから読み込むことで）情報を貰うというスタイルです。

これはこれで便利なのですが、それぞれのパーツが自主的にCPUに情報を教えたい場合、例えばPPU（ビデオ）が、「画面が描き終わったよ」などとCPUに伝えたい場合、メモリーマップドIOだけでは不便です。もしもメモリーマップドIOだけだったら、CPUは画面が描き終わった事を知りたい場合、PPUに聞き続ける（PPUのアドレスから値を読み続ける）しかなく、CPUは他の仕事ができなくなってしまいます。これはとても不便です。

このために用意されているのが、”割り込み”（Interrupt）という機構です。Linuxに詳しい方だったら「シグナル」のようなものだと考えてください。PPUやAPUがバスとは別の電線を使って、CPUに「割り込みして！」というシグナル伝える事が出来ます。CPUがその割り込みシグナルを受け取ると、実行中のプログラムをいったん中断して「割り込みハンドラ(ISR; Interrupt Serivice Routine)」というプログラムを実行し始めます。このプログラムの中で、CPUはどうして割り込まれたのかを”とある方法”（それは、割り込みを実装するときにお話しましょう）で知り、その内容（例：画面が描き終わった）に応じた処理を行ってから、割り込みを起こしたパーツに「割り込みしたよ」とメモリマップドIOを通じて伝え（Acknowledge）、その後続きのプログラムを実行します。

メモリマップドIOとは少し違いますが、これも、同じように全体をまとめ上げるクラスに、仲介してもらいましょう。

### 時間

何のこっちゃ？と思われるかもしれませんが、つまり、CPUやその他のパーツが動作するのに掛かる時間のことです。実はこの部分はかなり気をつかわなければならないのです！

というのも、「PPUがとある処理をするのに掛かる時間は、CPUの＊＊命令N回分の時間だから、N回＊＊命令を実行して、その処理が終わるのを待機しよう」とやっているゲームが、実に多いのです！今ではCPUの命令実行時間が同じ命令でも変わる事もあり考えられませんが、昔は割と普通だったみたいです…。

CPUが司令塔ですから、このCPUが命令を実行するのに合わせて動く時計を作りましょう。そのCPU時計に合わせて、他のパーツが動いてくれるように設計するのです。これも、先述のまとめ上げるクラスにやって貰いましょう。

## 0x0202 クラス図を描いて、設計の最終段階！

CPUと他のパーツが一緒に動くための仕組みをいくつか見てきました。どうやら、CPUと他のパーツを協調して動作させるためのクラスを一番上に用意して、その下にCPUその他のパーツを並列で置いて、まとめ上げるクラスを仲介して動作させればうまくいきそうです。この仲介役をVirtual Machineクラスとし、各パーツはこのクラスのメンバオブジェクトとしましょう（3）。

各パーツの動作で、他のパーツへの干渉（バスを介した情報のやりとり、割り込みシグナルの送信、タイミングの同期）が必要になった場合、必ず上位の存在であるVirtual Machineクラスを経由させることで、各パーツの独立性を高め、デバッグしやすくすることを狙います。多少オーバーヘッドが有りそうですが、C++ですし、コンパイラの最適化がきっとうまくやってくれるでしょう。

さて、次の章からは、具体的にこれらを少しずつ実装していきます。やっとコードが！出るぞ～！

